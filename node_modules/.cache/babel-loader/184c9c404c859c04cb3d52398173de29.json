{"ast":null,"code":"//import _ from \"lodash\"; //import lodash library\nimport TMDB, { KEY } from \"../apis/TMDB\"; //Action Creators inside Action Creator\n//This must be passed into connect() in our postlist component\n\n/*\nexport const fetchPostsAndUsers = () => async (dispatch, getState) => {\n  console.log(\"About to fetch posts\");\n  await dispatch(fetchPosts()); //Must dispatch manually because regularly it is dispatched using the connect() in the component we must await before using the data in this action creator since it is an async request\n  const userIds = _.uniq(_.map(getState().posts, \"userId\")); //This doesn't run until the await above has the data\n  //lodash has a map method we are using it since it has some great features\n  userIds.forEach(id => dispatch(fetchUser(id))); //iterate over array of userIds and fetch user using fetchUser action creator this will onlh fetch once and if having the same argument passed it will return the same return value of the same argument\n}; */\n//action creator\n//Short syntax\n//Applying thunk to action creator that is async await to request API\n\nexport const fetchMovies = searchTerm => async dispatch => {\n  const response = await TMDB.get(`/search/movie?api_key=${KEY}&query=${searchTerm}`);\n  dispatch({\n    type: \"FETCH_MOVIES\",\n    payload: response\n  });\n}; //action creator\n\n/* export const fetchUser = id => async dispatch => {\n  const response = await TMDB.get(`/users/${id}`);\n\n  dispatch({ type: \"FETCH_USER\", payload: response.data });\n}; */\n\n/* Memoize Solution\nexport const fetchUser = id => dispatch => _fetchUser(id, dispatch);\n\n//_ means private function. Don't touch unless you know what you're doing\n//This fetches the user only one time\nconst _fetchUser = _.memoize(async (id, dispatch) => {\n  const response = await TMDB.get(`/users/${id}`);\n\n  dispatch({ type: \"FETCH_USER\", payload: response.data });\n});\n*/\n//Long syntax\n\n/* Explanation application of thunk\n//This is a async action creator we need to use thunk!!!\nexport const fetchPosts = () => {\n  //async\n  //if we're not using getState it will not be an argument\n  return async dispatch => {\n    const response = await TMDB.get(\"/posts\"); //await response\n    dispatch({\n      type: \"FETCH_POSTS\",\n      payload: response, //put response here from the asyn await request from API\n    });\n  };\n};*/\n\n/*\n//TOTALLY FINE!!! We can still use regular action creators\nexport const selectPost = () => {\n  return {\n    type: \" SELECT_POST\",\n  };\n};\n*/","map":{"version":3,"sources":["/Users/cedrickmonesit/Desktop/movie-template/src/actions/index.js"],"names":["TMDB","KEY","fetchMovies","searchTerm","dispatch","response","get","type","payload"],"mappings":"AAAA;AAEA,OAAOA,IAAP,IAAeC,GAAf,QAA0B,cAA1B,C,CAEA;AACA;;AACA;;;;;;;;AASA;AACA;AACA;;AACA,OAAO,MAAMC,WAAW,GAAGC,UAAU,IAAI,MAAMC,QAAN,IAAkB;AACzD,QAAMC,QAAQ,GAAG,MAAML,IAAI,CAACM,GAAL,CACpB,yBAAwBL,GAAI,UAASE,UAAW,EAD5B,CAAvB;AAIAC,EAAAA,QAAQ,CAAC;AAAEG,IAAAA,IAAI,EAAE,cAAR;AAAwBC,IAAAA,OAAO,EAAEH;AAAjC,GAAD,CAAR;AACD,CANM,C,CAQP;;AACA;;;;;;AAMA;;;;;;;;;;;AAYA;;AACA;;;;;;;;;;;;;;AAaA","sourcesContent":["//import _ from \"lodash\"; //import lodash library\n\nimport TMDB, { KEY } from \"../apis/TMDB\";\n\n//Action Creators inside Action Creator\n//This must be passed into connect() in our postlist component\n/*\nexport const fetchPostsAndUsers = () => async (dispatch, getState) => {\n  console.log(\"About to fetch posts\");\n  await dispatch(fetchPosts()); //Must dispatch manually because regularly it is dispatched using the connect() in the component we must await before using the data in this action creator since it is an async request\n  const userIds = _.uniq(_.map(getState().posts, \"userId\")); //This doesn't run until the await above has the data\n  //lodash has a map method we are using it since it has some great features\n  userIds.forEach(id => dispatch(fetchUser(id))); //iterate over array of userIds and fetch user using fetchUser action creator this will onlh fetch once and if having the same argument passed it will return the same return value of the same argument\n}; */\n\n//action creator\n//Short syntax\n//Applying thunk to action creator that is async await to request API\nexport const fetchMovies = searchTerm => async dispatch => {\n  const response = await TMDB.get(\n    `/search/movie?api_key=${KEY}&query=${searchTerm}`,\n  );\n\n  dispatch({ type: \"FETCH_MOVIES\", payload: response });\n};\n\n//action creator\n/* export const fetchUser = id => async dispatch => {\n  const response = await TMDB.get(`/users/${id}`);\n\n  dispatch({ type: \"FETCH_USER\", payload: response.data });\n}; */\n\n/* Memoize Solution\nexport const fetchUser = id => dispatch => _fetchUser(id, dispatch);\n\n//_ means private function. Don't touch unless you know what you're doing\n//This fetches the user only one time\nconst _fetchUser = _.memoize(async (id, dispatch) => {\n  const response = await TMDB.get(`/users/${id}`);\n\n  dispatch({ type: \"FETCH_USER\", payload: response.data });\n});\n*/\n\n//Long syntax\n/* Explanation application of thunk\n//This is a async action creator we need to use thunk!!!\nexport const fetchPosts = () => {\n  //async\n  //if we're not using getState it will not be an argument\n  return async dispatch => {\n    const response = await TMDB.get(\"/posts\"); //await response\n    dispatch({\n      type: \"FETCH_POSTS\",\n      payload: response, //put response here from the asyn await request from API\n    });\n  };\n};*/\n/*\n//TOTALLY FINE!!! We can still use regular action creators\nexport const selectPost = () => {\n  return {\n    type: \" SELECT_POST\",\n  };\n};\n*/\n"]},"metadata":{},"sourceType":"module"}